expression RangeStart = null meta [IsParameterQuery=true, Type="DateTime", IsParameterQueryRequired=false]
	lineageTag: 90085870-f708-4bc2-90c1-3a343e88a26b
	queryGroup: 'üõ†Ô∏è Setup'

	annotation PBI_ResultType = Null

	annotation PBI_NavigationStepName = Navigation

expression RangeEnd = null meta [IsParameterQuery=true, Type="DateTime", IsParameterQueryRequired=false]
	lineageTag: 695f1d3b-7b1a-49fa-8d83-f2c25dc787de
	queryGroup: 'üõ†Ô∏è Setup'

	annotation PBI_ResultType = Null

	annotation PBI_NavigationStepName = Navigation

expression '‚ñ∂Ô∏è  START HERE' = ```
		let
		    // Storage
		    StorageUrl = #"Cluster URI",
		    UrlSegments = if StorageUrl <> null then Text.Split(StorageUrl, "/") else {},
		    UrlSegmentCount = List.Count(UrlSegments),
		    StorageCheck = 
		        if StorageUrl = "" or StorageUrl = null then {"‚úñ Invalid", "Storage URL not specified."}
		        else if Text.StartsWith(StorageUrl, "https://") = false then {"‚úñ Invalid", "Storage URL must be a valid HTTPS path."} 
		        else if (UrlSegmentCount = 4 and Text.Lower(UrlSegments{3}) = "ingestion") or (UrlSegmentCount = 7 and Text.Lower(UrlSegments{5}) = "Files" and Text.Lower(UrlSegments{6}) = "ingestion") then (
		            let
		                // Looks like hubs; try to get hub version
		                Settings = try Json.Document(AzureStorage.DataLake(StorageUrl & (if UrlSegmentCount = 3 then "/config" else "/../config")){[Name="settings.json"]}[Content], 1252) otherwise null,
		                HubVersion = if Settings <> null then try Settings[version] otherwise null else null,
		                Output = 
		                    if HubVersion = null then (
		                        if UrlSegmentCount = 4                                               and Text.Lower(UrlSegments{3}) = "ingestion" then {"‚ùìÔ∏è Unconfirmed", "Unable to confirm FinOps hub version from storage: " & Text.Split(StorageUrl, "."){0} & "."}
		                        else if UrlSegmentCount = 7 and Text.Lower(UrlSegments{5}) = "Files" and Text.Lower(UrlSegments{6}) = "ingestion" then {"‚ùìÔ∏è Unconfirmed", "Unable to confirm FinOps hub version from OneLake: " & Text.Split(StorageUrl, "."){0} & "."}
		                        else {"‚úñÔ∏è Invalid", "Configured storage account does not have FinOps hubs deployed."}
		                    )
		                    else {"‚úîÔ∏è Specified", "Will use FinOps hub v" & HubVersion & " storage: " & Text.Split(StorageUrl, "."){0} & "."}
		            in
		                Output
		        )
		        else if (try AzureStorage.DataLake(StorageUrl) otherwise null) <> null then {"‚úîÔ∏è Specified", "Will use exports in storage account: " & Text.Split(StorageUrl, "."){0} & "."}
		        // TODO: Read export manifests from the storage account to validate data is available
		        else {"‚úñÔ∏è Invalid", "Unable to connect to the specified storage account: " & Text.Split(StorageUrl, "."){0} & "."},
		
		    // Incremental refresh
		    DateEnd = RangeEnd,
		    DateStart = RangeStart,
		    DateMonths = #"Number of Months",
		    DateStartEffective = if DateStart <> null and DateStart <> "" then DateStart else Date.AddMonths(if DateEnd <> null and DateEnd <> "" then DateEnd else Date.AddMonths(Date.StartOfMonth(DateTime.LocalNow()), 1), -DateMonths+1),
		    _formatDate = (d) => try DateTime.ToText(d, [Format="MMM d, yyyy"]) otherwise d,
		    DateStartFormat = 
		        if (DateStart = null or DateStart = "") and (DateMonths = null or DateMonths < 1) then "*"
		        else if (DateStart = null or DateStart = "") and DateMonths <> null and DateMonths >= 1 then _formatDate(DateStartEffective)
		        else _formatDate(DateStart),
		    DateEndFormat = if DateEnd = null or DateEnd = "" then "*" else _formatDate(DateEnd),
		    DateValue = 
		        if DateStartFormat = "*" and DateEndFormat = "*" then "(no dates)" else DateStartFormat & " - " & DateEndFormat,
		    DateCheck =
		        // TODO: Catch when DateEnd and DateMonths create a start date in the future
		        if DateValue = "(no dates)"   then {"‚ö†Ô∏è Warning", "Will pull all data. May fail if over $2-5M."}
		        else if DateStart <> null and DateStart <> "" and DateEndFormat = "*" then {"‚ö†Ô∏è Warning", "Will pull all data after start date. May fail if over $2-5M."}
		        else if (DateStart = null or DateStart = "")  and DateEndFormat = "*" then {"‚úîÔ∏è Specified", "Will pull data for the last " & (if DateMonths = 1 then "1 month" else (Text.From(DateMonths) & " months")) & "."}
		        else if DateStartFormat = "*" then {"‚ö†Ô∏è Warning", "Will pull all data before end date. May fail if over $2-5M."}
		        else if DateStart <> null and DateStart <> "" and DateStart > DateEnd then {"‚úñ Invalid", "The start date must be before the end date."}
		        else if DateStart <> null and DateStart <> "" and DateStart < DateEnd then try {"‚úîÔ∏è Specified", "Will pull data for " & Number.ToText(Duration.Days(DateEnd - DateStart)) & " days."} otherwise {"‚úñ Invalid", "Unable to parse dates: " & DateStart & " - " & DateEnd & "."}
		        else if DateStart = null and DateMonths <> null and DateMonths < 1 then {"‚úñ Invalid", "The number of months must be more 1 or more (empty for all)."}
		        else if DateStart = null and DateMonths <> null and DateMonths > 0 then try {"‚úîÔ∏è Specified", "Will pull data for " & Number.ToText(Duration.Days(DateEnd - DateStartEffective)) & " days."} otherwise {"‚úñ Invalid", "Unable to parse dates: " & DateStartEffective & " - " & DateEnd & "."}
		        else {"‚úñ Invalid", "Unable to confirm dates: " & (if DateStart = null then "(null)" else ("'"&Text.From(DateStart)&"'")) & " - " & (if DateEnd = null then "(null)" else ("'"&Text.From(DateEnd)&"'")) & " or # of months: " & (if DateMonths = null then "(null)" else ("'"&Text.From(DateMonths)&"'")) & "."},
		
		    // 
		    /*
		    Step1 = Table.InsertRows(#table({"Instructions", "Value", "Status", "Message"}, {}), 0, {
		        [ Instructions = "‚ë† Set the data source parameter on the left", Value = SourceType, Status = SourceCheck{0}, Message = SourceCheck{1} ],
		        [ Instructions = "        ‚ûñ About exports @ https://aka.ms/finops/toolkit/exports", Value = "", Status = "", Message = "" ],
		        [ Instructions = "        ‚ûñ About FinOps hubs @ https://aka.ms/finops/hubs", Value = "", Status = "", Message = "" ],
		        [ Instructions = "", Value = "", Status = "", Message = "" ]
		    }),
		
		    MainChecks = Table.InsertRows(Step1, 4, 
		    */
		
		    MainChecks = Table.InsertRows(#table({"Instructions", "Value", "Status", "Message"}, {}), 0, {
		        [ Instructions = "‚ë† Set the storage URL on the left", Value = StorageUrl, Status = StorageCheck{0}, Message = StorageCheck{1} ],
		        [ Instructions = "        If using FinOps hubs:", Value = "", Status = "", Message = "" ],
		        [ Instructions = "        ‚ûñ Go to your hub resource group", Value = "", Status = "", Message = "" ],
		        [ Instructions = "        ‚ûñ Open Deployments > `hub` > Outputs", Value = "", Status = "", Message = "" ],
		        [ Instructions = "        ‚ûñ Copy the 'HubUrlForPowerBI' value", Value = "", Status = "", Message = "" ],
		        [ Instructions = "        ", Value = "", Status = "", Message = "" ],
		        [ Instructions = "        If using exports:", Value = "", Status = "", Message = "" ],
		        [ Instructions = "        ‚ûñ Go to your storage account", Value = "", Status = "", Message = "" ],
		        [ Instructions = "        ‚ûñ Open Endpoints", Value = "", Status = "", Message = "" ],
		        [ Instructions = "        ‚ûñ Copy the 'Data Lake Storage' value", Value = "", Status = "", Message = "" ],
		        [ Instructions = "        ‚ûñ Optionally add a container or file path", Value = "", Status = "", Message = "" ],
		        [ Instructions = "        ", Value = "", Status = "", Message = "" ],
		        [ Instructions = "‚ë¢ Optional: Set the desired date range", Value = DateValue, Status = DateCheck{0}, Message = DateCheck{1} ],
		        //[ Instructions = "        ‚ûñ Dates are only required to support incremental refresh", Value = "", Status = "", Message = if DateCheck{0} = "‚ö†Ô∏è Warning" then "Incremental refresh requires dates." else if DateCheck{0} = "‚úîÔ∏è Specified" then "Please configure incremental refresh to support up to $2-5M/mo." else "" ],
		        [ Instructions = "        ‚ûñ NOTE: Power BI only supports a total of $2-5M without incremental refresh", Value = "", Status = "", Message = "" ],
		        [ Instructions = "        ", Value = "", Status = "", Message = "" ]
		    })
		in
		    MainChecks
		```
	lineageTag: 6cfe80b8-1c4b-4c11-9916-43fc98b49dac
	queryGroup: 'üõ†Ô∏è Setup'

	annotation PBI_ResultType = Table

	annotation PBI_NavigationStepName = Navigation

/// Optional. Number of months to include in the report before the RangeEnd date. Ignored if RangeStart is specified. Default: (all available data).
expression 'Number of Months' = 3 meta [IsParameterQuery=true, Type="Number", IsParameterQueryRequired=false]
	lineageTag: 1d47668d-4de6-404c-8e53-f89a35081e8b
	queryGroup: 'üõ†Ô∏è Setup'

	annotation PBI_NavigationStepName = Navigation

	annotation PBI_ResultType = Number

/// URI of the FinOps hub Azure Data Explorer cluster to pull data from. Copy from the "clusterUri" deployment output.
/// 
/// Pro tip: As a shortcut, you can alternatively use the "{name}.{region}" subset of the URI.
expression 'Cluster URI' = "khub-mf.westcentralus" meta [IsParameterQuery=true, Type="Text", IsParameterQueryRequired=true]
	lineageTag: 5204bb07-e939-4ac4-b800-ade703a31af4
	queryGroup: 'üõ†Ô∏è Setup'

	annotation PBI_NavigationStepName = Navigation

	annotation PBI_ResultType = Text

/// Indicate whether you want to view daily or monthly data in this report. If using daily, you may need to set the number of months to be a lower number depending on how many resources you have.
expression 'Daily or Monthly' = "Daily" meta [IsParameterQuery=true, List={"Daily", "Monthly"}, DefaultValue="Daily", Type="Text", IsParameterQueryRequired=true]
	lineageTag: cf257a84-c284-44da-87a5-2d9cf8f66c28
	queryGroup: 'üõ†Ô∏è Setup'

	annotation PBI_NavigationStepName = Navigation

	annotation PBI_ResultType = Text

/// Cost summarized by resource
expression ChargeBreakdown =
		let
		    lookback = Text.From(if #"Number of Months" = "" or #"Number of Months" = null then 999 else #"Number of Months"),
		    Source = AzureDataExplorer.Contents(#"Cluster URI", "Hub", "
		
		    Costs_v1_0
		    | where ChargePeriodStart >= monthsago(" & lookback & ")
		    //
		    // Filter out cost allocation changes
		    | where isempty(x_CostAllocationRuleName)
		    //
		    // Fix missing costs
		    | extend ContractedCost = iff(isempty(ContractedCost) or ContractedCost == 0, EffectiveCost, ContractedCost)
		    | extend ListCost = iff(isempty(ListCost) or ListCost == 0, ContractedCost, ListCost)
		    //
		    | summarize
		        BilledCost     = sum(BilledCost),
		        ContractedCost = sum(ContractedCost),
		        EffectiveCost  = sum(EffectiveCost),
		        ListCost       = sum(ListCost)
		        by
		            BillingAccountId,
		            BillingAccountName,
		            BillingCurrency,
		            ChargeCategory,
		            ChargeClass,
		            ChargePeriodEnd,
		            ChargePeriodStart,
		            CommitmentDiscountCategory,
		            CommitmentDiscountStatus,
		            CommitmentDiscountType,
		            PricingCategory,
		            ProviderName,
		            PublisherName,
		            ResourceType,
		            ServiceCategory,
		            ServiceName,
		            SubAccountName,
		            x_Operation,
		            x_PricingSubcategory,
		            x_PublisherCategory,
		            x_SkuMeterCategory,
		            x_SkuMeterName,
		            x_SkuMeterSubcategory,
		            x_SkuPartNumber,
		            x_SkuServiceFamily,
		            x_SkuTerm,
		            x_SkuTier,
		            x_UsageType
		    | project
		        BilledCost,
		        BillingAccountId,
		        BillingAccountName,
		        BillingCurrency,
		        ChargeCategory,
		        ChargeClass,
		        ChargePeriodEnd,
		        ChargePeriodStart,
		        CommitmentDiscountCategory,
		        CommitmentDiscountStatus,
		        CommitmentDiscountType,
		        ContractedCost,
		        EffectiveCost,
		        ListCost,
		        PricingCategory,
		        ProviderName,
		        PublisherName,
		        ResourceType,
		        ServiceCategory,
		        ServiceName,
		        SubAccountName,
		        x_CommitmentDiscountSavings = ContractedCost - EffectiveCost,
		        x_NegotiatedDiscountSavings = ListCost - ContractedCost,
		        x_Operation,
		        x_PricingSubcategory,
		        x_PublisherCategory,
		        x_SkuMeterCategory,
		        x_SkuMeterName,
		        x_SkuMeterSubcategory,
		        x_SkuPartNumber,
		        x_SkuServiceFamily,
		        x_SkuTerm,
		        x_SkuTier,
		        x_TotalSavings = ListCost - EffectiveCost,
		        x_UsageType
		
		    ", [MaxRows=null, MaxSize=null, NoTruncate=false, AdditionalSetStatements=null, ClientRequestIdPrefix="ftk-Resources-PurchaseCosts"])
		in
		    Source
	lineageTag: 6f8beadd-bc59-4787-aa80-41f366a905f0
	queryGroup: 'Data Explorer'

	annotation PBI_NavigationStepName = Navigation

	annotation PBI_ResultType = Exception

/// Cost summarized by resource
expression PurchaseCosts =
		let
		    lookback = Text.From(if #"Number of Months" = "" or #"Number of Months" = null then 999 else #"Number of Months"),
		    Source = AzureDataExplorer.Contents(#"Cluster URI", "Hub", "
		
		    Costs_v1_0
		    | where ChargePeriodStart >= monthsago(" & lookback & ")
		    //
		    // Filter out cost allocation changes
		    | where isempty(x_CostAllocationRuleName)
		    //
		    // Fix missing costs
		    | extend ContractedCost = iff(isempty(ContractedCost) or ContractedCost == 0, EffectiveCost, ContractedCost)
		    | extend ListCost = iff(isempty(ListCost) or ListCost == 0, ContractedCost, ListCost)
		    //
		    | where ChargeCategory == 'Purchase'
		    | project
		        BilledCost,
		        BillingAccountId,
		        BillingAccountName,
		        BillingCurrency,
		        BillingPeriodEnd,
		        BillingPeriodStart,
		        ChargeClass,
		        // ChargeDescription,
		        ChargeFrequency,
		        ChargePeriodEnd,
		        ChargePeriodStart,
		        CommitmentDiscountCategory,
		        // CommitmentDiscountId,
		        // CommitmentDiscountName,
		        CommitmentDiscountType,
		        ContractedCost,
		        ContractedUnitPrice,
		        EffectiveCost,
		        ListCost,
		        ListUnitPrice,
		        PricingCategory,
		        PricingQuantity,
		        PricingUnit,
		        ProviderName,
		        PublisherName,
		        // ServiceCategory,
		        // ServiceName,
		        SkuId,
		        SkuPriceId,
		        SubAccountId,
		        SubAccountName,
		        // x_BillingAccountAgreement,
		        // x_BillingAccountId,
		        // x_BillingAccountName,
		        // x_BillingProfileId,
		        // x_BillingProfileName,
		        x_EffectiveUnitPrice,
		        x_Operation,
		        x_PricingBlockSize,
		        x_PricingUnitDescription,
		        x_PublisherCategory,
		        x_PublisherId,
		        x_ServicePeriodEnd,
		        x_ServicePeriodStart,
		        x_SkuDescription,
		        // x_SkuDetails,
		        // x_SkuIsCreditEligible,
		        // x_SkuMeterCategory,
		        // x_SkuMeterId,
		        // x_SkuMeterName,
		        // x_SkuMeterSubcategory,
		        x_SkuOrderId,
		        x_SkuOrderName,
		        // x_SkuServiceFamily,
		        x_SkuTerm,
		        x_UsageType
		
		    ", [MaxRows=null, MaxSize=null, NoTruncate=false, AdditionalSetStatements=null, ClientRequestIdPrefix="ftk-Resources-PurchaseCosts"])
		in
		    Source
	lineageTag: 59c91efd-cb04-4a05-b5fe-8233e8a08822
	queryGroup: 'Data Explorer'

	annotation PBI_NavigationStepName = Navigation

	annotation PBI_ResultType = Table

/// Cost summarized by resource
expression ResourceCosts =
		let
		    lookback = Text.From(if #"Number of Months" = "" or #"Number of Months" = null then 999 else #"Number of Months"),
		    Source = AzureDataExplorer.Contents(#"Cluster URI", "Hub", "
		
		    Costs_v1_0
		    | where ChargePeriodStart >= monthsago(" & lookback & ")
		    //
		    // Filter out cost allocation changes
		    | where isempty(x_CostAllocationRuleName)
		    //
		    // Fix missing costs
		    | extend ContractedCost = iff(isempty(ContractedCost) or ContractedCost == 0, EffectiveCost, ContractedCost)
		    | extend ListCost = iff(isempty(ListCost) or ListCost == 0, ContractedCost, ListCost)
		    //
		    | summarize
		        AvailabilityZone = take_any(AvailabilityZone),
		        BilledCost = sum(BilledCost),
		        BillingAccountName = take_any(BillingAccountName),
		        " & (if #"Daily or Monthly" = "Daily" then "" else "ChargePeriodEnd = max(ChargePeriodEnd), ChargePeriodStart = min(ChargePeriodStart),") & "
		        ContractedCost = sum(ContractedCost),
		        EffectiveCost = sum(EffectiveCost),
		        ListCost = sum(ListCost),
		        ProviderName = take_any(ProviderName),
		        RegionId = take_any(RegionId),
		        RegionName = take_any(RegionName),
		        ResourceName = take_any(ResourceName),
		        ResourceType = take_any(ResourceType),
		        ServiceCategory = take_any(ServiceCategory),
		        ServiceName = take_any(ServiceName),
		        SubAccountName = take_any(SubAccountName),
		        x_ResourceGroupName = take_any(x_ResourceGroupName),
		        x_ResourceType = take_any(x_ResourceType)
		        by
		            BillingAccountId,
		            BillingCurrency,
		            " & (if #"Daily or Monthly" = "Daily" then "ChargePeriodEnd, ChargePeriodStart," else "") & "
		            x_ChargePeriodMonth = startofmonth(ChargePeriodStart),
		            CommitmentDiscountCategory,
		            CommitmentDiscountId,
		            CommitmentDiscountName,
		            CommitmentDiscountType,
		            CommitmentDiscountStatus,
		            ResourceId,
		            SubAccountId
		            // Tags,
		            // x_CostCategories,
		            // x_CostCenter
		    | project
		        AvailabilityZone,
		        BilledCost,
		        BillingAccountId,
		        BillingAccountName,
		        BillingCurrency,
		        ChargePeriodEnd,
		        ChargePeriodStart,
		        CommitmentDiscountCategory,
		        CommitmentDiscountId,
		        CommitmentDiscountName,
		        CommitmentDiscountType,
		        CommitmentDiscountStatus,
		        ContractedCost,
		        EffectiveCost,
		        ListCost,
		        ProviderName,
		        RegionId,
		        RegionName,
		        ResourceId,
		        ResourceName,
		        ResourceType,
		        ServiceCategory,
		        ServiceName,
		        SubAccountId,
		        SubAccountName,
		        // Tags,
		        x_ChargePeriodMonth,
		        x_CommitmentDiscountSavings = ContractedCost - EffectiveCost,
		        // x_CostCategories,
		        // x_CostCenter
		        x_NegotiatedDiscountSavings = ListCost - ContractedCost,
		        x_ReportingDate = " & (if #"Daily or Monthly" = "Daily" then "startofday(ChargePeriodStart)" else "x_ChargePeriodMonth") & ",
		        x_ResourceGroupName,
		        x_ResourceType,
		        x_TotalSavings = ListCost - EffectiveCost
		
		    ", [MaxRows=null, MaxSize=null, NoTruncate=false, AdditionalSetStatements=null, ClientRequestIdPrefix="ftk-Resources-ResourceCosts"])
		in
		    Source
	lineageTag: 38a24ef5-0abf-4c6c-818b-85517f2bfa1f
	queryGroup: 'Data Explorer'

	annotation PBI_NavigationStepName = Navigation

	annotation PBI_ResultType = Table

/// Cost summarized by resource
expression TagCosts =
		let
		    lookback = Text.From(if #"Number of Months" = "" or #"Number of Months" = null then 999 else #"Number of Months"),
		    Source = AzureDataExplorer.Contents(#"Cluster URI", "Hub", "
		
		    // Set the tags you want to promote as 'tag_*' columns in this array
		    let promotedTags = dynamic(['Application', 'BusinessUnit', 'CostCenter', 'Department', 'Division', 'Env', 'Owner', 'Product', 'Project', 'Purpose', 'Service']);
		    //
		    // This option matches tag keys that may have different case (e.g., 'env' and 'ENV')
		    let caseInsensitive = true;
		    //
		    // This option removes any unwanted spaces before or after the tag key
		    let trimSpaces = true;
		    //
		    let checktag = (key: string) {
		        let tagColumn = print tag = promotedTags | mv-expand tag | where tag == key or (caseInsensitive and tag =~ key) | project tag = strcat('tag_', tag);
		        iff(toscalar(tagColumn | count) > 0, toscalar(tagColumn | limit 1), '')
		    };
		    Costs_v1_0
		    | where ChargePeriodStart >= monthsago(" & lookback & ")
		    // | where isnotempty(Tags)
		    //
		    // Filter out cost allocation changes
		    | where isempty(x_CostAllocationRuleName)
		    //
		    // Fix missing costs
		    | extend ContractedCost = iff(isempty(ContractedCost) or ContractedCost == 0, EffectiveCost, ContractedCost)
		    | extend ListCost = iff(isempty(ListCost) or ListCost == 0, ContractedCost, ListCost)
		    //
		    | summarize
		        BilledCost = sum(BilledCost),
		        // BillingAccountName = take_any(BillingAccountName),
		        " & (if #"Daily or Monthly" = "Daily" then "" else "ChargePeriodEnd = max(ChargePeriodEnd), ChargePeriodStart = min(ChargePeriodStart),") & "
		        ContractedCost = sum(ContractedCost),
		        EffectiveCost = sum(EffectiveCost),
		        ListCost = sum(ListCost)
		        // ProviderName = take_any(ProviderName),
		        // SubAccountName = take_any(SubAccountName),
		        by
		            // BillingAccountId,
		            BillingCurrency,
		            " & (if #"Daily or Monthly" = "Daily" then "ChargePeriodEnd, ChargePeriodStart," else "") & "
		            CommitmentDiscountCategory,
		            CommitmentDiscountId,
		            CommitmentDiscountName,
		            CommitmentDiscountType,
		            CommitmentDiscountStatus,
		            ResourceId,
		            // SubAccountId
		            Tags = tostring(Tags),
		            // x_BillingAccountId,
		            // x_BillingAccountName,
		            // x_BillingProfileId,
		            // x_BillingProfileName,
		            x_ChargePeriodMonth = startofmonth(ChargePeriodStart),
		            x_CostCategories = tostring(x_CostCategories),
		            x_CostCenter
		            // x_InvoiceSectionId,
		            // x_InvoiceSectionName,
		            // x_Project
		    | project
		        BilledCost,
		        // BillingAccountId,
		        // BillingAccountName,
		        BillingCurrency,
		        ChargePeriodEnd,
		        ChargePeriodStart,
		        ContractedCost,
		        EffectiveCost,
		        ListCost,
		        // SubAccountId,
		        // SubAccountName,
		        Tags,
		        // x_BillingAccountId,
		        // x_BillingAccountName,
		        // x_BillingProfileId,
		        // x_BillingProfileName,
		        x_CommitmentDiscountSavings = ContractedCost - EffectiveCost,
		        x_CostCategories,
		        x_CostCenter,
		        // x_InvoiceSectionId,
		        // x_InvoiceSectionName,
		        // x_Project
		        x_NegotiatedDiscountSavings = ListCost - ContractedCost,
		        x_ReportingDate = " & (if #"Daily or Monthly" = "Daily" then "startofday(ChargePeriodStart)" else "x_ChargePeriodMonth") & ",
		        x_TotalSavings = ListCost - EffectiveCost
		    //
		    // Extract tags
		    | extend tmp_Tags = parse_json(Tags)
		    | mv-apply tmp_Tags on (
		        extend TagName = tostring(bag_keys(tmp_Tags)[0])
		        | extend cleanTagName = iff(trimSpaces, trim(' ', TagName), TagName)
		        | where cleanTagName in (promotedTags) or (caseInsensitive and cleanTagName in~ (promotedTags))
		        | extend tagColumn = strcat('tag_', promotedTags[array_index_of(parse_json(tolower(promotedTags)), tolower(cleanTagName))])
		        | where isnotempty(tagColumn)
		        | summarize tmp_Tags = make_bag(bag_pack(tagColumn, tostring(tmp_Tags[TagName])))
		    )
		    | evaluate bag_unpack(tmp_Tags)
		
		    ", [MaxRows=null, MaxSize=null, NoTruncate=false, AdditionalSetStatements=null, ClientRequestIdPrefix="ftk-Resources-TagCosts"])
		in
		    Source
	lineageTag: ee7b9535-af23-49c6-9f25-f41111b32922
	queryGroup: 'Data Explorer'

	annotation PBI_NavigationStepName = Navigation

	annotation PBI_ResultType = Table

