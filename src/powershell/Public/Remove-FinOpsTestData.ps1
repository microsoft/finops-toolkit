# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.

<#
    .SYNOPSIS
    Removes test data from a FinOps hub environment.

    .DESCRIPTION
    Purges test data generated by New-FinOpsTestData from Azure Data Explorer,
    Azure Storage, and the local test-data folder. By default only the local
    folder is cleaned. Pass -StorageAccountName and/or -AdxClusterUri to also
    clean cloud resources.

    Note: This command does not manage Microsoft Fabric Real-Time Intelligence.
    If your hub uses Fabric, clean up Fabric data separately. Test data
    generated by New-FinOpsTestData is compatible with both ADX and Fabric
    ingestion paths.

    Safety features:
    - Local-only cleanup by default (no cloud params = no cloud deletion).
    - Storage deletion is targeted: the command scans every manifest in the
      msexports and ingestion containers for the _ftkTestData marker written
      by New-FinOpsTestData. Only folders whose manifest contains the marker
      are deleted, so production data in the same storage account is preserved.
      If no markers are found, deletion is refused. Use -Force to wipe all blobs.
    - ADX cleanup requires -Force because .clear table removes ALL rows
      (production and test). There is no way to selectively clear test rows
      from ADX. Do not ingest test data into a cluster that contains
      production data. If you accidentally mix them, clear the ADX tables
      and re-ingest production data from storage (production exports are
      preserved by the targeted storage deletion).

    Steps performed:
    1. Stop ADF triggers (optional, prevents re-ingestion during cleanup)
    2. Purge ADX tables in the Hub and Ingestion databases (requires -Force)
    3. Verify ADX update policies are intact after clearing
    4. Delete test-data folders from storage (only folders with _ftkTestData marker)
    5. Delete local test-data folder

    .PARAMETER AdxClusterUri
    Optional. Azure Data Explorer cluster URI.
    Example: https://finopsdemoadx4uj6pm.italynorth.kusto.windows.net
    Requires -Force because .clear table removes ALL data, not just test data.

    .PARAMETER StorageAccountName
    Optional. Azure Storage account name for blob cleanup. The command scans
    every manifest for the _ftkTestData marker and deletes only the folders
    that contain marked manifests. Production data in the same account is
    preserved. Pass -Force to wipe all blobs regardless.

    .PARAMETER AdfName
    Azure Data Factory name for stopping triggers during cleanup.

    .PARAMETER ResourceGroupName
    Azure resource group name containing the ADF instance.

    .PARAMETER StopTriggers
    Stop ADF triggers before cleanup to prevent re-ingestion during the purge.
    Requires -AdfName and -ResourceGroupName.

    .PARAMETER Force
    Bypass safety checks. Required when using -AdxClusterUri because .clear
    table removes all data. For storage, -Force causes a full container wipe
    when no _ftkTestData markers are found (without -Force, deletion is refused
    if no markers exist).

    .PARAMETER OutputPath
    Local directory to delete. Default: ./test-data

    .EXAMPLE
    Remove-FinOpsTestData
    # Deletes the local ./test-data folder only.

    .EXAMPLE
    Remove-FinOpsTestData -StorageAccountName "stfinopsdemo4uj6pmwee34z"
    # Deletes test-data blobs from storage (after verifying _ftkTestData marker) and the local folder.

    .EXAMPLE
    Remove-FinOpsTestData -StorageAccountName "stfinopsdemo4uj6pmwee34z" -AdxClusterUri "https://mycluster.eastus.kusto.windows.net" -Force
    # Full cleanup: purges ADX tables, storage blobs, and the local folder. -Force is required for ADX.

    .LINK
    https://aka.ms/ftk/Remove-FinOpsTestData
#>
function Remove-FinOpsTestData
{
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidUsingWriteHost', '', Justification = 'Colored interactive output is intentional for progress reporting and summary display')]
    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    param(
        [string]$AdxClusterUri,

        [string]$StorageAccountName,

        [string]$AdfName,

        [string]$ResourceGroupName,

        [switch]$StopTriggers,

        [switch]$Force,

        [string]$OutputPath = "./test-data"
    )

    # ADF trigger names matching the default FinOps Hub ADF trigger names.
    $AdfTriggerNames = @('msexports_ManifestAdded', 'ingestion_ManifestAdded')

    $ErrorActionPreference = 'Continue'

    # --- Determine which scopes are requested ---

    $cleanStorage = [bool]$StorageAccountName
    $cleanAdx = [bool]$AdxClusterUri

    # --- Safety: ADX requires -Force because .clear table is indiscriminate ---
    if ($cleanAdx -and -not $Force)
    {
        Write-Error (
            "Azure Data Explorer cleanup requires -Force because '.clear table' " +
            "removes ALL data (production and test) from every table. There is " +
            "no way to selectively delete test rows. If you have mixed test and " +
            "production data in ADX, you will need to re-ingest production data " +
            "from storage after clearing. Re-run with -Force to proceed."
        )
        return
    }

    Write-Host ""
    Write-Host ("=" * 70) -ForegroundColor Red
    Write-Host "  Remove-FinOpsTestData — Environment Cleanup" -ForegroundColor Red
    Write-Host ("=" * 70) -ForegroundColor Red
    Write-Host ""
    Write-Host "  Scope:" -ForegroundColor Yellow
    Write-Host "    Local files:    Yes ($OutputPath)" -ForegroundColor White
    Write-Host "    Storage blobs:  $(if ($cleanStorage) { 'Yes (' + $StorageAccountName + ')' } else { 'No (pass -StorageAccountName to include)' })" -ForegroundColor White
    Write-Host "    ADX tables:     $(if ($cleanAdx) { 'Yes (' + $AdxClusterUri + ') — ALL rows will be deleted!' } else { 'No (pass -AdxClusterUri -Force to include)' })" -ForegroundColor White
    if ($AdfName) { Write-Host "    ADF triggers:   $AdfName" -ForegroundColor White }
    Write-Host ""

    if (-not $PSCmdlet.ShouldProcess("$(if ($cleanAdx) { 'ADX tables, ' })$(if ($cleanStorage) { 'storage blobs, ' })local files", "Permanently delete"))
    {
        Write-Host "Aborted." -ForegroundColor Yellow
        return
    }

    # -----------------------------------------------------------------
    # Step 1: Stop ADF Triggers (prevents re-ingestion during cleanup)
    # -----------------------------------------------------------------
    if ($StopTriggers -and $AdfName -and $ResourceGroupName)
    {
        Write-Host "[1/4] Stopping ADF triggers..." -ForegroundColor Cyan
        foreach ($trigger in $AdfTriggerNames)
        {
            $triggerObj = Get-AzDataFactoryV2Trigger -ResourceGroupName $ResourceGroupName -DataFactoryName $AdfName -Name $trigger -ErrorAction SilentlyContinue
            $state = $triggerObj.RuntimeState
            if ($state -eq "Started")
            {
                Write-Host "  Stopping $trigger..." -ForegroundColor Gray
                Stop-AzDataFactoryV2Trigger -ResourceGroupName $ResourceGroupName -DataFactoryName $AdfName -Name $trigger -Force | Out-Null
                Write-Host "  ✓ $trigger stopped" -ForegroundColor Green
            }
            else
            {
                Write-Host "  $trigger already stopped (state=$state)" -ForegroundColor Gray
            }
        }
    }
    else
    {
        Write-Host "[1/4] Skipping ADF trigger stop (no -StopTriggers or missing -AdfName/-ResourceGroupName)" -ForegroundColor Gray
    }

    # -----------------------------------------------------------------
    # Step 2: Purge all ADX tables in Hub and Ingestion databases
    #         (Requires -Force because .clear table is indiscriminate)
    # -----------------------------------------------------------------
    Write-Host ""
    if (-not $cleanAdx)
    {
        Write-Host "[2/4] Skipping ADX cleanup (no -AdxClusterUri)" -ForegroundColor Gray
    }
    else
    {
        Write-Host "[2/4] Purging ADX tables (Force mode)..." -ForegroundColor Cyan
        Write-Warning "ADX does not support selective row deletion. ALL data (including any production data) will be removed from every table. If you have production data, re-ingest it from storage after this completes."

        $adxToken = $null
        try
        {
            $prevWarningPreference = $WarningPreference
            $WarningPreference = "SilentlyContinue"
            $adxToken = (Get-AzAccessToken -ResourceUrl $AdxClusterUri -AsSecureString).Token | ConvertFrom-SecureString -AsPlainText
            $WarningPreference = $prevWarningPreference
        }
        catch
        {
            Write-Warning "Could not get ADX access token. ADX tables will not be purged."
        }

        if ($adxToken)
        {
            $adxHeaders = @{ "Authorization" = "Bearer $adxToken"; "Content-Type" = "application/json" }

            $databases = @("Ingestion", "Hub")
            foreach ($db in $databases)
            {
                Write-Host "  Database: $db" -ForegroundColor Yellow

                # List all tables via REST API
                $listBody = @{ db = $db; csl = ".show tables | project TableName" } | ConvertTo-Json
                $tableNames = @()
                try
                {
                    $listResult = Invoke-RestMethod -Uri "$AdxClusterUri/v1/rest/mgmt" -Method Post -Headers $adxHeaders -Body $listBody -ErrorAction Stop
                    if ($listResult.Tables -and $listResult.Tables[0].Rows)
                    {
                        foreach ($row in $listResult.Tables[0].Rows)
                        {
                            $name = if ($row -is [array]) { $row[0] } else { $row }
                            if ($name -and $name -notlike '.*') { $tableNames += $name }
                        }
                    }
                }
                catch
                {
                    Write-Host "  Could not list tables in $db, trying known table names..." -ForegroundColor Gray
                    $tableNames = if ($db -eq "Ingestion")
                    {
                        @(
                            "Costs_raw", "Prices_raw", "Recommendations_raw", "Transactions_raw",
                            "CommitmentDiscountUsage_raw", "ActualCosts_raw", "AmortizedCosts_raw",
                            "MACC_Lots_raw", "MACC_Events_raw"
                        )
                    }
                    else
                    {
                        @(
                            "Costs_final_v1_0", "Costs_final_v1_2", "Costs_final_v1_3",
                            "Prices_final_v1_2", "Recommendations_final_v1_2",
                            "Transactions_final_v1_2", "CommitmentDiscountUsage_final_v1_2",
                            "MACC_ManualEntry"
                        )
                    }
                }

                foreach ($tableName in $tableNames)
                {
                    Write-Host "    Clearing $tableName..." -ForegroundColor Gray
                    $clearBody = @{ db = $db; csl = ".clear table ['$tableName'] data" } | ConvertTo-Json
                    try
                    {
                        Invoke-RestMethod -Uri "$AdxClusterUri/v1/rest/mgmt" -Method Post -Headers $adxHeaders -Body $clearBody -ErrorAction Stop | Out-Null
                        Write-Host "    ✓ $tableName cleared" -ForegroundColor DarkGreen
                    }
                    catch
                    {
                        Write-Host "    ⚠ $tableName skipped (may not exist)" -ForegroundColor Gray
                    }
                }
            }

            # Verify update policies are still intact after clearing
            Write-Host ""
            Write-Host "[2b/4] Verifying update policies..." -ForegroundColor Cyan

            # Define all required update policies: FinalTable -> SourceTable -> TransformFunction
            $requiredPolicies = @(
                @{ FinalTable = "Costs_final_v1_2"; SourceTable = "Costs_raw"; TransformFunction = "Costs_transform_v1_2()" }
                @{ FinalTable = "Prices_final_v1_2"; SourceTable = "Prices_raw"; TransformFunction = "Prices_transform_v1_2()" }
                @{ FinalTable = "CommitmentDiscountUsage_final_v1_2"; SourceTable = "CommitmentDiscountUsage_raw"; TransformFunction = "CommitmentDiscountUsage_transform_v1_2()" }
                @{ FinalTable = "Recommendations_final_v1_2"; SourceTable = "Recommendations_raw"; TransformFunction = "Recommendations_transform_v1_2()" }
                @{ FinalTable = "Transactions_final_v1_2"; SourceTable = "Transactions_raw"; TransformFunction = "Transactions_transform_v1_2()" }
            )

            $policiesFixed = 0
            $policiesOk = 0

            foreach ($policy in $requiredPolicies)
            {
                $finalTable = $policy.FinalTable
                $sourceTable = $policy.SourceTable
                $transformFn = $policy.TransformFunction

                # Check current update policy
                $showBody = @{ db = "Ingestion"; csl = ".show table ['$finalTable'] policy update" } | ConvertTo-Json
                $policyExists = $false

                try
                {
                    $showResult = Invoke-RestMethod -Uri "$AdxClusterUri/v1/rest/mgmt" -Method Post -Headers $adxHeaders -Body $showBody -ErrorAction Stop
                    if ($showResult.Tables -and $showResult.Tables[0].Rows)
                    {
                        foreach ($row in $showResult.Tables[0].Rows)
                        {
                            $policyJson = if ($row -is [array]) { $row[1] } else { $row }
                            if ($policyJson -and $policyJson -ne "[]" -and $policyJson -ne "null" -and $policyJson.Length -gt 5)
                            {
                                $policyExists = $true
                            }
                        }
                    }
                }
                catch
                {
                    Write-Host "  ⚠ Could not check policy for $finalTable (table may not exist yet)" -ForegroundColor Gray
                    continue
                }

                if ($policyExists)
                {
                    Write-Host "  ✓ $finalTable — update policy OK" -ForegroundColor DarkGreen
                    $policiesOk++
                }
                else
                {
                    Write-Host "  ✗ $finalTable — update policy MISSING, re-applying..." -ForegroundColor Yellow

                    $policyDef = "[{""IsEnabled"":true, ""Source"":""$sourceTable"", ""Query"":""$transformFn"", ""IsTransactional"":true, ""PropagateIngestionProperties"":true}]"
                    $alterCsl = ".alter table ['$finalTable'] policy update @'$policyDef'"
                    $alterBody = @{ db = "Ingestion"; csl = $alterCsl } | ConvertTo-Json

                    try
                    {
                        Invoke-RestMethod -Uri "$AdxClusterUri/v1/rest/mgmt" -Method Post -Headers $adxHeaders -Body $alterBody -ErrorAction Stop | Out-Null
                        Write-Host "    ✓ Policy applied: $sourceTable → $transformFn → $finalTable" -ForegroundColor Green
                        $policiesFixed++
                    }
                    catch
                    {
                        Write-Host "    ✗ Failed to apply policy for $finalTable — $($_.Exception.Message)" -ForegroundColor Red
                    }
                }
            }

            Write-Host ""
            if ($policiesFixed -gt 0)
            {
                Write-Host "  Update Policy Summary: $policiesOk OK, $policiesFixed fixed" -ForegroundColor Yellow
            }
            else
            {
                Write-Host "  ✓ All $policiesOk update policies verified" -ForegroundColor Green
            }
        }
    } # end if ($cleanAdx)

    # -----------------------------------------------------------------
    # Step 3: Delete test-data blobs from storage (targeted by marker)
    #
    # Instead of wiping entire containers, we scan every manifest for
    # the _ftkTestData watermark and delete only the folder that
    # contains each marked manifest. This keeps production data safe
    # even when test and production data coexist.
    # -----------------------------------------------------------------
    Write-Host ""
    if (-not $cleanStorage)
    {
        Write-Host "[3/4] Skipping storage cleanup (no -StorageAccountName)" -ForegroundColor Gray
    }
    else
    {
        Write-Host "[3/4] Scanning storage for test data manifests..." -ForegroundColor Cyan

        $storageContext = New-AzStorageContext -StorageAccountName $StorageAccountName -UseConnectedAccount
        $containers = @("msexports", "ingestion")

        # Collect folder prefixes that contain test-data manifests
        $testFolders = @()   # Array of @{ Container; Prefix }

        foreach ($container in $containers)
        {
            $manifestBlobs = Get-AzStorageBlob -Container $container -Context $storageContext -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -like "*manifest*json" }

            foreach ($blob in $manifestBlobs)
            {
                try
                {
                    $tempFile = [System.IO.Path]::GetTempFileName()
                    Get-AzStorageBlobContent -Container $container -Blob $blob.Name -Context $storageContext -Destination $tempFile -Force -ErrorAction Stop | Out-Null
                    $content = Get-Content $tempFile -Raw | ConvertFrom-Json -ErrorAction Stop
                    Remove-Item $tempFile -Force -ErrorAction SilentlyContinue
                    if ($content._ftkTestData -eq $true)
                    {
                        # Derive the folder prefix (everything up to the last '/')
                        $lastSlash = $blob.Name.LastIndexOf('/')
                        $folderPrefix = if ($lastSlash -gt 0) { $blob.Name.Substring(0, $lastSlash + 1) } else { '' }
                        $testFolders += @{ Container = $container; Prefix = $folderPrefix }
                        Write-Host "    Found test data: $container/$folderPrefix" -ForegroundColor Gray
                    }
                }
                catch
                {
                    Write-Verbose "Skipping non-test manifest: $($blob.Name)"
                }
            }
        }

        if ($testFolders.Count -eq 0 -and -not $Force)
        {
            Write-Warning (
                "No test data markers (_ftkTestData) found in storage account '$StorageAccountName'. " +
                "This storage may contain production data. Skipping storage cleanup. " +
                "Use -Force to delete ALL blobs in msexports and ingestion containers regardless."
            )
        }
        elseif ($testFolders.Count -eq 0 -and $Force)
        {
            Write-Warning "No test data markers found but -Force specified. Deleting ALL blobs in both containers..."
            foreach ($container in $containers)
            {
                Write-Host "  Container: $container" -ForegroundColor Yellow
                Get-AzStorageBlob -Container $container -Context $storageContext -ErrorAction SilentlyContinue | Remove-AzStorageBlob -Force
                Write-Host "    ✓ $container purged (Force)" -ForegroundColor Green
            }
        }
        else
        {
            Write-Host "  Found $($testFolders.Count) test data folder(s) to remove" -ForegroundColor Green

            $deletedBlobs = 0
            foreach ($folder in $testFolders)
            {
                $blobs = Get-AzStorageBlob -Container $folder.Container -Prefix $folder.Prefix -Context $storageContext -ErrorAction SilentlyContinue
                $count = 0
                foreach ($b in $blobs)
                {
                    $b | Remove-AzStorageBlob -Force
                    $count++
                }
                $deletedBlobs += $count
                Write-Host "    ✓ $($folder.Container)/$($folder.Prefix) — $count blob(s) deleted" -ForegroundColor DarkGreen
            }
            Write-Host "  ✓ Removed $deletedBlobs blob(s) across $($testFolders.Count) folder(s)" -ForegroundColor Green
        }
    } # end if ($cleanStorage)

    # -----------------------------------------------------------------
    # Step 4: Delete local test-data folder
    # -----------------------------------------------------------------
    Write-Host ""
    Write-Host "[4/4] Cleaning local test-data..." -ForegroundColor Cyan

    $localTestDataPath = Resolve-Path $OutputPath -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Path
    if ($localTestDataPath -and (Test-Path $localTestDataPath))
    {
        Remove-Item -Recurse -Force $localTestDataPath
        Write-Host "  ✓ Deleted $localTestDataPath" -ForegroundColor Green
    }
    else
    {
        Write-Host "  No local test-data folder found" -ForegroundColor Gray
    }
    # Also check default path if different
    $cwdOutputPath = Join-Path (Get-Location) "test-data"
    if ((Test-Path $cwdOutputPath) -and ($cwdOutputPath -ne $localTestDataPath))
    {
        Remove-Item -Recurse -Force $cwdOutputPath
        Write-Host "  ✓ Deleted $cwdOutputPath" -ForegroundColor Green
    }

    # -----------------------------------------------------------------
    # Done
    # -----------------------------------------------------------------
    Write-Host ""
    Write-Host ("=" * 70) -ForegroundColor Green
    Write-Host "  ✅ Cleanup complete!" -ForegroundColor Green
    Write-Host ("=" * 70) -ForegroundColor Green
    Write-Host ""
    Write-Host "Next steps:" -ForegroundColor Yellow
    if ($cleanStorage -or $cleanAdx)
    {
        Write-Host "  Re-generate and upload in one command:" -ForegroundColor White
        Write-Host "  New-FinOpsTestData -RowCount 300000 -Upload ``" -ForegroundColor Gray
        Write-Host "      -StorageAccountName $StorageAccountName ``" -ForegroundColor Gray
        Write-Host "      -AdfName <adf-name> -ResourceGroupName <rg-name> -StartTriggers" -ForegroundColor Gray
    }
    else
    {
        Write-Host "  Re-generate local test data:" -ForegroundColor White
        Write-Host "  New-FinOpsTestData -RowCount 300000" -ForegroundColor Gray
    }
    Write-Host ""
}
